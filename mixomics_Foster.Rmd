---
title: "Mixomics on Foster-constrained data"
output: html_notebook
---

```{r, echo=FALSE, include=FALSE}
library(phyloseq)
library(mixOmics)
library(readxl)
library(reshape2)
library(tidyverse)
theme_set(theme_classic(base_size = 14))
```

Import all the necessary matrices for analysis
```{r import}
files <- list.files(path = here::here("corr_mats/"))
otu_file_list <- str_subset(files,"clr(.)+otu")
tax_file_list <- str_subset(files,"tax")
ms_file_list <- str_subset(files, "ms")
#Import otu counts
otu_list <- map(otu_file_list, 
                    ~read_csv(file = here::here(str_c("corr_mats/",.))))
otu_mat_list <- otu_list %>% 
  map(column_to_rownames, var = "...1") %>% 
  map(as.matrix)
#Import MS data
mq_mat <- read_csv(file = here::here(str_c("corr_mats/",ms_file_list))) %>% 
  column_to_rownames(var = "...1") %>% 
  as.matrix()
```

Import the metadata and create sub-divided matrices.
We will be doing correlations within just Ileum or Colon and within noIBD, active, or inactive IBD
```{r import-meta}
meta_full <- read_excel(here::here("Metadata.xlsx")) %>% 
  select("sample" = `#SampleID`, "group" = Group, everything()) %>% 
  mutate(sample = str_remove(sample, "Rep")) %>% 
  filter(sample %in% rownames(mq_mat)) %>% 
  mutate(across(matches("(Active)|(TI_resection)|(Cholestyramine)"), ~as.character(fct_recode(as_factor(.x), 
                                                Yes = "1", No = "0", Not_applicable = "NA"))))
#Prepare metadata tables
meta_list_starter <- map(vector(mode = "list", length = 2), ~ meta_full)
meta_list <-meta_list_starter %>% 
  map2(rep(c("Colon","Ileum"), each = 1), 
       ~filter(.x, Tissue_type == .y)) 
#Name the list for convenience
names(meta_list) <- c("Colon","Ileum")
```

Make appropriate matrices for each group.
Add taxonomy to otu matrices instead of feature IDs
```{r subset_mq}
dfs_names <- str_c(rep(c("Family","Genus", "Species"), times = 2),rep(names(meta_list),each = 3), sep = "_")
otu_filt_list <- rep(otu_mat_list, times = length(meta_list)) %>% 
  map2(rep(meta_list, each = length(dfs_names)/length(meta_list)), ~ .x [pull(.y,var = sample),]) %>% 
  set_names(nm=dfs_names)
#Get taxonomy to assign meaningul names
tax_list <- map(tax_file_list, 
                    ~read_csv(file = here::here(str_c("corr_mats/",.))))
#Add taxonomy information to each result
otu_dfs <- otu_filt_list %>% 
  map(t) %>% 
  map(as_tibble, rownames = "feature")
df_tax_list <- map2(otu_dfs, rep(tax_list,times = length(otu_dfs)/length(tax_list)),left_join, by = c("feature" = "...1"))
df_better_names <-  df_tax_list %>% 
  keep(str_detect(names(df_tax_list),"Species", negate = T))
#Check if family and/or genus names are unique in the list
map2(df_better_names, c("Family", "Genus","Family", "Genus"), ~any(duplicated(pull(.x,var = .y))))
#None of the families are duplicated, but some genera are - check those
idx_list <- map2(df_better_names, c("Family", "Genus","Family", "Genus"), ~which(duplicated(pull(.x,var = .y))))
#They are just genus_uncultured, replace them with family instead
df_fam_gen <- df_better_names %>% 
  modify_if(str_detect(names(df_better_names),"Genus"), 
            ~mutate(.x, Genus_better = case_when(
              str_detect(Genus,"uncultured") ~ Family,
              TRUE ~ Genus
            )))
#Create the new list of matrices
otu_final_list <- df_fam_gen %>% 
  map2(rep(c("Family","Genus_better"), times = 2), ~ column_to_rownames(.x, var = .y)) %>% 
  map(select, -Kingdom, -Phylum, -Class, -Order,-matches("Family"), -Genus, -Species, - feature, -matches("Genus_better")) %>% 
  map(t) %>% 
  map(as.matrix)
```

Further filter the proteomics data to just include DE proteins between active/inactive IBD vs control in each group
```{r select_top_prots}
#Import the results
da_res <- map(list.files(here::here("spear_subset_on_Foster"), pattern = "full_"),
              ~read_csv( file = here::here(str_c("spear_subset_on_Foster/",.)))) 
da_res <- set_names(da_res, nm = list.files(here::here("spear_subset_on_Foster"), pattern = "full_"))
#Reduce the results to one table, and filter afterwards
da_res_interest <- da_res %>% 
  reduce(left_join, by = c("gene.name","first.id")) %>% 
  select(gene.name,first.id, contains("padj"), -contains("grand")) %>% 
  filter(if_any(contains("adj"), ~.<0.01))
#Get the protein names to select
da_prots <- da_res_interest %>% 
  select(gene.name) %>% 
  separate(gene.name, into = letters [1:20], sep = " ") %>% 
  pivot_longer(letters [2:20], names_to = "letters", values_to = "secondary_names")
da_prots_final <- c(da_prots$a,da_prots$secondary_names) %>% 
  . [!is.na(.)] %>% 
  str_remove_all(";")

#Create the new mq_list
mq_top_list <- map(vector(mode = "list", length = length(dfs_names)), ~ mq_mat [,colnames(mq_mat) %in% da_prots_final]) %>% 
  map2(rep(meta_list, each=length(dfs_names)/length(meta_list)), ~ .x [pull(.y,var = sample),]) %>% 
  set_names(nm=dfs_names)
#Ensure rows are in the same order for the matrices
all(map2_lgl(otu_final_list, keep(mq_top_list, str_detect(names(mq_top_list), "Species", negate = T)), ~all(rownames(.x) == rownames(.y))))
```
Do not run DIABLO on species level data, prepare the matrices for DIABLO
```{r diablo-prep}
#Create a factor for separation based on ActiveIBD status
Y_list <- meta_list %>% 
  map(pull,Active_IBD) %>% 
  map(as_factor) %>% 
  map(fct_relevel, "Not_applicable", "No", "Yes") %>% 
  rep(each=2)
#Create list of matrices
X_list <- list(keep(mq_top_list, str_detect(names(mq_top_list), "Species", negate = T)),
                 otu_final_list) %>% 
  transpose() %>% 
  modify_depth(1, ~set_names(., nm = c("protein","microbiome")))
```

Run diablo analysis
```{r diablo-analysis}
#Run starter DIABLO
res.dblo <- map2(X_list, Y_list, block.splsda)
#pdf(here::here("mixomics_res/PCA-like plot.pdf"))
walk2(res.dblo, names(res.dblo),~plotIndiv(.x, ind.names = F, 
          legend=TRUE, title = .y,
          col.per.group = c("grey69","orange", "brown"),
          ellipse=F))
#dev.off()
```


```{r diablo-analysis-2, fig.width=8, fig.height=6}
#pdf(here::here("mixomics_res/Correlation circles.pdf"), width = 8, height = 6)
cutoff <- rep(c(0.65, 0.65), each = 2)
pwalk(list(res.dblo, names(res.dblo),cutoff), 
      ~plotVar(..1, var.names = c(T, T),
        legend=TRUE, cutoff = ..3, cex = c(1.5,1.5), col = c("cornflowerblue","firebrick3"),
        title = str_c(..2," Correlation Circle Plot\nCut-off of ",..3)))
#dev.off()
```


```{r diablo-analysis-loadings, fig.width=9, fig.height=6}
loadings_plot_list <- list(rep(res.dblo, each = 2),
                           rep(names(res.dblo), each = 2),
                           rep(c(1,2), times = length(res.dblo)))
#pdf(here::here("mixomics_res/Loadings plots.pdf"), width = 9, height = 6)
pwalk(loadings_plot_list, 
      ~plotLoadings(..1, comp = ..3, contrib = "max", ndisplay = 10, 
                     legend.color = c("grey69","orange", "brown"),
                     title = ..2, size.name = 1.2, size.legend = 1.2))
#dev.off()
```


```{r diablo-cim, fig.width=8, fig.height=7, eval=FALSE}
cutoff <- 0.65
for (i in seq_along(res.dblo)) {
  plot.new()
  cimDiablo(res.dblo [[i]], color.blocks = c("cornflowerblue","firebrick3"), 
          comp = c(1,2), margin=c(8,20), legend.position = "right", color.Y = c("grey69","orange", "brown"), 
          title =  names(res.dblo) [[i]],
          cutoff = cutoff, save = "png", 
          name.save = here::here(str_c("mixomics_res/", names(res.dblo) [[i]],"_Cim")))
}
```


```{r diablo-network, fig.width=8, fig.height=7, eval=FALSE}
cutoff <- 0.6
for (i in seq_along(res.dblo)) {
  network(res.dblo [[i]], cutoff = cutoff, 
        color.node = c("lightblue","indianred1"), shape.node = c('circle','circle'),
        alpha.node = 0.5, symkey = T, interactive = F, save = "png",
        name.save = here::here(str_c("mixomics_res/", names(res.dblo) [[i]],"_Network")))
}
```


